最大子序列:要找出由数组中元素组成的和最大的 连续 子序列.注意连续

最长递增子序列:动态规划,或者二分查找

最长公共字串LCS:要求子串连续,可用动态规划.首先维护最长长度变量max
要计算dp[i][j],如果S1[0:i-1]==S2[0:j-1],
dp[i][j] = dp[i - 1][j - 1] + 1;
max = Math.max(max, dp[i][j])
如果不想等,dp[i][j]置0,因为要求连续

最长公共子序列:最长公共子序列与最长公共子串的区别在于最长公共子序列不要求在原字符串中是连续的，比如ADE和ABCDE的最长公共子序列是ADE。
新建二维dp数组dp[i][j]表示S1[0:i]与S[0:j]的最长公共子串
当 S1i==S2j 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1i 这个值，最长公共子序列长度加 1，即 dp[i][j] = dp[i-1][j-1] + 1。
当 S1i != S2j 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，或者 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，取它们的最大者，即 dp[i][j] = max{ dp[i-1][j], dp[i][j-1] }。
与最长递增子序列对比:
dp[i]表示以Si为结尾的最长递增子序列长度,子序列必须包含Si.在最长公共子序列中，dp[i][j] 表示 S1 中前 i 个字符与 S2 中前 j 个字符的最长公共子序列长度，不一定包含 S1i 和 S2j。
在求最终解时，最长公共子序列中 dp[N][M] 就是最终解，而最长递增子序列中 dp[N] 不是最终解，因为以 SN 为结尾的最长递增子序列不一定是整个序列最长递增子序列，需要遍历一遍 dp 数组找到最大者。
