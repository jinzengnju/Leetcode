package Dynamic;
//把一根绳子剪成多段，并且使得每段的长度乘积最大。
//
//        n = 2
//        return 1 (2 = 1 + 1)
//
//        n = 10
//        return 36 (10 = 3 + 3 + 4)
public class IntegerBreak {
    public int getMaxMultiply(int n){
        int[] dp=new int[n+1];
        dp[1]=1;
        for (int i=2;i<n;i++){
            for (int j=0;j<i;j++){
                dp[i]=Math.max(dp[i],Math.max(j*(i-j),dp[j]*(i-j)));
            }
        }
        return dp[n];
    }

    //dp[i]表示绳子长为i时，能组成积的最大值
//    比如现在我们要长为10的绳子，需要提前知道长度为0，1，2，3...9分割后能组成乘积的最大值
//    假如现在有长度为10的绳子，遍历到j=5时，那么现在有一段长为5的绳子和一段长为5的绳子（这段可以任意分割，可分割也可不分），求乘积的最大值
//    那么问题来了，dp[5]可以分，为什么剩下长度为5的不分呢？
//    理解一：我们动态规划的递推公式限制了增加的长度为一整段，再乘上dp[5]的值
//    理解二：dp[5]*5，假如后面5分割，会分割成比5小的段来。但是因为我们遍历了j，肯定会遍历到j=0，1，2，3，4
}
